import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/dtw/lib/validate.js
var require_validate = __commonJS({
  "node_modules/dtw/lib/validate.js"(exports, module) {
    function validateSequence(sequence, sequenceParameterName) {
      if (!(sequence instanceof Array)) {
        throw new TypeError("Invalid sequence '" + sequenceParameterName + "' type: expected an array");
      }
      if (sequence.length < 1) {
        throw new Error("Invalid number of sequence data points for '" + sequenceParameterName + "': expected at least one");
      }
      if (typeof sequence[0] !== "number") {
        throw new TypeError("Invalid data points types for sequence '" + sequenceParameterName + "': expected a number");
      }
    }
    module.exports = {
      sequence: validateSequence
    };
  }
});

// node_modules/dtw/lib/matrix.js
var require_matrix = __commonJS({
  "node_modules/dtw/lib/matrix.js"(exports, module) {
    var createArray = function(length, value) {
      if (typeof length !== "number") {
        throw new TypeError("Invalid length type");
      }
      if (typeof value === "undefined") {
        throw new Error("Invalid value: expected a value to be provided");
      }
      var array = new Array(length);
      for (var index = 0; index < length; index++) {
        array[index] = value;
      }
      return array;
    };
    var createMatrix = function(m, n, value) {
      var matrix = [];
      for (var rowIndex = 0; rowIndex < m; rowIndex++) {
        matrix.push(createArray(n, value));
      }
      return matrix;
    };
    module.exports = {
      create: createMatrix
    };
  }
});

// node_modules/dtw/lib/comparison.js
var require_comparison = __commonJS({
  "node_modules/dtw/lib/comparison.js"(exports, module) {
    var EPSILON = 2220446049250313e-31;
    var nearlyEqual = function(i, j, epsilon) {
      var iAbsolute = Math.abs(i);
      var jAbsolute = Math.abs(j);
      var difference = Math.abs(i - j);
      var equal = i === j;
      if (!equal) {
        equal = difference < EPSILON;
        if (!equal) {
          equal = difference <= Math.max(iAbsolute, jAbsolute) * epsilon;
        }
      }
      return equal;
    };
    module.exports = {
      EPSILON,
      nearlyEqual
    };
  }
});

// node_modules/dtw/lib/distanceFunctions/manhattan.js
var require_manhattan = __commonJS({
  "node_modules/dtw/lib/distanceFunctions/manhattan.js"(exports, module) {
    var distance = function(x, y) {
      var difference = x - y;
      var manhattanDistance = Math.abs(difference);
      return manhattanDistance;
    };
    module.exports = {
      distance
    };
  }
});

// node_modules/dtw/lib/distanceFunctions/euclidean.js
var require_euclidean = __commonJS({
  "node_modules/dtw/lib/distanceFunctions/euclidean.js"(exports, module) {
    var distance = function(x, y) {
      var difference = x - y;
      var euclideanDistance = Math.sqrt(difference * difference);
      return euclideanDistance;
    };
    module.exports = {
      distance
    };
  }
});

// node_modules/dtw/lib/distanceFunctions/squaredEuclidean.js
var require_squaredEuclidean = __commonJS({
  "node_modules/dtw/lib/distanceFunctions/squaredEuclidean.js"(exports, module) {
    var distance = function(x, y) {
      var difference = x - y;
      var squaredEuclideanDistance = difference * difference;
      return squaredEuclideanDistance;
    };
    module.exports = {
      distance
    };
  }
});

// node_modules/dtw/lib/dtw.js
var require_dtw = __commonJS({
  "node_modules/dtw/lib/dtw.js"(exports, module) {
    var debug = require_browser()("dtw");
    var validate = require_validate();
    var matrix = require_matrix();
    var comparison = require_comparison();
    function validateOptions(options) {
      if (typeof options !== "object") {
        throw new TypeError("Invalid options type: expected an object");
      } else if (typeof options.distanceMetric !== "string" && typeof options.distanceFunction !== "function") {
        throw new TypeError("Invalid distance types: expected a string distance type or a distance function");
      } else if (typeof options.distanceMetric === "string" && typeof options.distanceFunction === "function") {
        throw new Error("Invalid parameters: provide either a distance metric or function but not both");
      }
      if (typeof options.distanceMetric === "string") {
        var normalizedDistanceMetric = options.distanceMetric.toLowerCase();
        if (normalizedDistanceMetric !== "manhattan" && normalizedDistanceMetric !== "euclidean" && normalizedDistanceMetric !== "squaredeuclidean") {
          throw new Error("Invalid parameter value: Unknown distance metric '" + options.distanceMetric + "'");
        }
      }
    }
    function retrieveDistanceFunction(distanceMetric) {
      var normalizedDistanceMetric = distanceMetric.toLowerCase();
      var distanceFunction = null;
      if (normalizedDistanceMetric === "manhattan") {
        distanceFunction = require_manhattan().distance;
      } else if (normalizedDistanceMetric === "euclidean") {
        distanceFunction = require_euclidean().distance;
      } else if (normalizedDistanceMetric === "squaredeuclidean") {
        distanceFunction = require_squaredEuclidean().distance;
      }
      return distanceFunction;
    }
    var DTW = function(options) {
      var state = { distanceCostMatrix: null };
      if (typeof options === "undefined") {
        state.distance = require_squaredEuclidean().distance;
      } else {
        validateOptions(options);
        if (typeof options.distanceMetric === "string") {
          state.distance = retrieveDistanceFunction(options.distanceMetric);
        } else if (typeof options.distanceFunction === "function") {
          state.distance = options.distanceFunction;
        }
      }
      this.compute = function(firstSequence, secondSequence, window2) {
        var cost = Number.POSITIVE_INFINITY;
        if (typeof window2 === "undefined") {
          cost = computeOptimalPath(firstSequence, secondSequence, state);
        } else if (typeof window2 === "number") {
          cost = computeOptimalPathWithWindow(firstSequence, secondSequence, window2, state);
        } else {
          throw new TypeError("Invalid window parameter type: expected a number");
        }
        return cost;
      };
      this.path = function() {
        var path = null;
        if (state.distanceCostMatrix instanceof Array) {
          path = retrieveOptimalPath(state);
        }
        return path;
      };
    };
    function validateComputeParameters(s, t) {
      validate.sequence(s, "firstSequence");
      validate.sequence(t, "secondSequence");
    }
    function computeOptimalPath(s, t, state) {
      debug("> computeOptimalPath");
      validateComputeParameters(s, t);
      var start = (/* @__PURE__ */ new Date()).getTime();
      state.m = s.length;
      state.n = t.length;
      var distanceCostMatrix = matrix.create(state.m, state.n, Number.POSITIVE_INFINITY);
      distanceCostMatrix[0][0] = state.distance(s[0], t[0]);
      for (var rowIndex = 1; rowIndex < state.m; rowIndex++) {
        var cost = state.distance(s[rowIndex], t[0]);
        distanceCostMatrix[rowIndex][0] = cost + distanceCostMatrix[rowIndex - 1][0];
      }
      for (var columnIndex = 1; columnIndex < state.n; columnIndex++) {
        var cost = state.distance(s[0], t[columnIndex]);
        distanceCostMatrix[0][columnIndex] = cost + distanceCostMatrix[0][columnIndex - 1];
      }
      for (var rowIndex = 1; rowIndex < state.m; rowIndex++) {
        for (var columnIndex = 1; columnIndex < state.n; columnIndex++) {
          var cost = state.distance(s[rowIndex], t[columnIndex]);
          distanceCostMatrix[rowIndex][columnIndex] = cost + Math.min(
            distanceCostMatrix[rowIndex - 1][columnIndex],
            // Insertion
            distanceCostMatrix[rowIndex][columnIndex - 1],
            // Deletion
            distanceCostMatrix[rowIndex - 1][columnIndex - 1]
          );
        }
      }
      var end = (/* @__PURE__ */ new Date()).getTime();
      var time = end - start;
      debug("< computeOptimalPath (" + time + " ms)");
      state.distanceCostMatrix = distanceCostMatrix;
      state.similarity = distanceCostMatrix[state.m - 1][state.n - 1];
      return state.similarity;
    }
    function computeOptimalPathWithWindow(s, t, w, state) {
      debug("> computeOptimalPathWithWindow");
      validateComputeParameters(s, t);
      var start = (/* @__PURE__ */ new Date()).getTime();
      state.m = s.length;
      state.n = t.length;
      var window2 = Math.max(w, Math.abs(s.length - t.length));
      var distanceCostMatrix = matrix.create(state.m + 1, state.n + 1, Number.POSITIVE_INFINITY);
      distanceCostMatrix[0][0] = 0;
      for (var rowIndex = 1; rowIndex <= state.m; rowIndex++) {
        for (var columnIndex = Math.max(1, rowIndex - window2); columnIndex <= Math.min(state.n, rowIndex + window2); columnIndex++) {
          var cost = state.distance(s[rowIndex - 1], t[columnIndex - 1]);
          distanceCostMatrix[rowIndex][columnIndex] = cost + Math.min(
            distanceCostMatrix[rowIndex - 1][columnIndex],
            // Insertion
            distanceCostMatrix[rowIndex][columnIndex - 1],
            // Deletion
            distanceCostMatrix[rowIndex - 1][columnIndex - 1]
          );
        }
      }
      var end = (/* @__PURE__ */ new Date()).getTime();
      var time = end - start;
      debug("< computeOptimalPathWithWindow (" + time + " ms)");
      distanceCostMatrix.shift();
      distanceCostMatrix = distanceCostMatrix.map(function(row) {
        return row.slice(1, row.length);
      });
      state.distanceCostMatrix = distanceCostMatrix;
      state.similarity = distanceCostMatrix[state.m - 1][state.n - 1];
      return state.similarity;
    }
    function retrieveOptimalPath(state) {
      debug("> retrieveOptimalPath");
      var start = (/* @__PURE__ */ new Date()).getTime();
      var rowIndex = state.m - 1;
      var columnIndex = state.n - 1;
      var path = [[rowIndex, columnIndex]];
      var epsilon = 1e-14;
      while (rowIndex > 0 || columnIndex > 0) {
        if (rowIndex > 0 && columnIndex > 0) {
          var min = Math.min(
            state.distanceCostMatrix[rowIndex - 1][columnIndex],
            // Insertion
            state.distanceCostMatrix[rowIndex][columnIndex - 1],
            // Deletion
            state.distanceCostMatrix[rowIndex - 1][columnIndex - 1]
          );
          if (comparison.nearlyEqual(min, state.distanceCostMatrix[rowIndex - 1][columnIndex - 1], epsilon)) {
            rowIndex--;
            columnIndex--;
          } else if (comparison.nearlyEqual(min, state.distanceCostMatrix[rowIndex - 1][columnIndex], epsilon)) {
            rowIndex--;
          } else if (comparison.nearlyEqual(min, state.distanceCostMatrix[rowIndex][columnIndex - 1], epsilon)) {
            columnIndex--;
          }
        } else if (rowIndex > 0 && columnIndex === 0) {
          rowIndex--;
        } else if (rowIndex === 0 && columnIndex > 0) {
          columnIndex--;
        }
        path.push([rowIndex, columnIndex]);
      }
      var end = (/* @__PURE__ */ new Date()).getTime();
      var time = end - start;
      debug("< retrieveOptimalPath (" + time + " ms)");
      return path.reverse();
    }
    module.exports = DTW;
  }
});

// node_modules/dtw/index.js
var require_dtw2 = __commonJS({
  "node_modules/dtw/index.js"(exports, module) {
    module.exports = require_dtw();
  }
});
export default require_dtw2();
//# sourceMappingURL=dtw.js.map
